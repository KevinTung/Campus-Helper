{"version":3,"sources":["index.js","Plugin.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _assert = _interopRequireDefault(require(\"assert\"));\n\nvar _Plugin = _interopRequireDefault(require(\"./Plugin\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _default({\n  types\n}) {\n  let plugins = null; // Only for test\n\n  global.__clearBabelAntdPlugin = () => {\n    plugins = null;\n  };\n\n  function applyInstance(method, args, context) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = plugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        const plugin = _step.value;\n\n        if (plugin[method]) {\n          plugin[method].apply(plugin, [...args, context]);\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  const Program = {\n    enter(path, {\n      opts = {}\n    }) {\n      // Init plugin instances once.\n      if (!plugins) {\n        if (Array.isArray(opts)) {\n          plugins = opts.map(({\n            libraryName,\n            libraryDirectory,\n            style,\n            camel2DashComponentName,\n            camel2UnderlineComponentName,\n            fileName,\n            customName,\n            transformToDefaultImport\n          }, index) => {\n            (0, _assert.default)(libraryName, 'libraryName should be provided');\n            return new _Plugin.default(libraryName, libraryDirectory, style, camel2DashComponentName, camel2UnderlineComponentName, fileName, customName, transformToDefaultImport, types, index);\n          });\n        } else {\n          (0, _assert.default)(opts.libraryName, 'libraryName should be provided');\n          plugins = [new _Plugin.default(opts.libraryName, opts.libraryDirectory, opts.style, opts.camel2DashComponentName, opts.camel2UnderlineComponentName, opts.fileName, opts.customName, opts.transformToDefaultImport, types)];\n        }\n      }\n\n      applyInstance('ProgramEnter', arguments, this); // eslint-disable-line\n    },\n\n    exit() {\n      applyInstance('ProgramExit', arguments, this); // eslint-disable-line\n    }\n\n  };\n  const methods = ['ImportDeclaration', 'CallExpression', 'MemberExpression', 'Property', 'VariableDeclarator', 'ArrayExpression', 'LogicalExpression', 'ConditionalExpression', 'IfStatement', 'ExpressionStatement', 'ReturnStatement', 'ExportDefaultDeclaration', 'BinaryExpression', 'NewExpression', 'ClassDeclaration'];\n  const ret = {\n    visitor: {\n      Program\n    }\n  };\n\n  for (var _i = 0; _i < methods.length; _i++) {\n    const method = methods[_i];\n\n    ret.visitor[method] = function () {\n      // eslint-disable-line\n      applyInstance(method, arguments, ret.visitor); // eslint-disable-line\n    };\n  }\n\n  return ret;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _path = require(\"path\");\n\nvar _helperModuleImports = require(\"@babel/helper-module-imports\");\n\nfunction transCamel(_str, symbol) {\n  const str = _str[0].toLowerCase() + _str.substr(1);\n\n  return str.replace(/([A-Z])/g, $1 => `${symbol}${$1.toLowerCase()}`);\n}\n\nfunction winPath(path) {\n  return path.replace(/\\\\/g, '/');\n}\n\nfunction normalizeCustomName(originCustomName) {\n  // If set to a string, treat it as a JavaScript source file path.\n  if (typeof originCustomName === 'string') {\n    const customNameExports = require(originCustomName);\n\n    return typeof customNameExports === 'function' ? customNameExports : customNameExports.default;\n  }\n\n  return originCustomName;\n}\n\nclass Plugin {\n  constructor(libraryName, libraryDirectory, style, camel2DashComponentName, camel2UnderlineComponentName, fileName, customName, transformToDefaultImport, types, index = 0) {\n    this.libraryName = libraryName;\n    this.libraryDirectory = typeof libraryDirectory === 'undefined' ? 'lib' : libraryDirectory;\n    this.camel2DashComponentName = typeof camel2DashComponentName === 'undefined' ? true : camel2DashComponentName;\n    this.camel2UnderlineComponentName = camel2UnderlineComponentName;\n    this.style = style || false;\n    this.fileName = fileName || '';\n    this.customName = normalizeCustomName(customName);\n    this.transformToDefaultImport = typeof transformToDefaultImport === 'undefined' ? true : transformToDefaultImport;\n    this.types = types;\n    this.pluginStateKey = `importPluginState${index}`;\n  }\n\n  getPluginState(state) {\n    if (!state[this.pluginStateKey]) {\n      state[this.pluginStateKey] = {}; // eslint-disable-line\n    }\n\n    return state[this.pluginStateKey];\n  }\n\n  importMethod(methodName, file, pluginState) {\n    if (!pluginState.selectedMethods[methodName]) {\n      const libraryDirectory = this.libraryDirectory;\n      const style = this.style;\n      const transformedMethodName = this.camel2UnderlineComponentName // eslint-disable-line\n      ? transCamel(methodName, '_') : this.camel2DashComponentName ? transCamel(methodName, '-') : methodName;\n      const path = winPath(this.customName ? this.customName(transformedMethodName) : (0, _path.join)(this.libraryName, libraryDirectory, transformedMethodName, this.fileName) // eslint-disable-line\n      );\n      pluginState.selectedMethods[methodName] = this.transformToDefaultImport // eslint-disable-line\n      ? (0, _helperModuleImports.addDefault)(file.path, path, {\n        nameHint: methodName\n      }) : (0, _helperModuleImports.addNamed)(file.path, methodName, path);\n\n      if (style === true) {\n        (0, _helperModuleImports.addSideEffect)(file.path, `${path}/style`);\n      } else if (style === 'css') {\n        (0, _helperModuleImports.addSideEffect)(file.path, `${path}/style/css`);\n      } else if (typeof style === 'function') {\n        const stylePath = style(path, file);\n\n        if (stylePath) {\n          (0, _helperModuleImports.addSideEffect)(file.path, stylePath);\n        }\n      }\n    }\n\n    return Object.assign({}, pluginState.selectedMethods[methodName]);\n  }\n\n  buildExpressionHandler(node, props, path, state) {\n    const file = path && path.hub && path.hub.file || state && state.file;\n    const types = this.types;\n    const pluginState = this.getPluginState(state);\n    props.forEach(prop => {\n      if (!types.isIdentifier(node[prop])) return;\n\n      if (pluginState.specified[node[prop].name] && types.isImportSpecifier(path.scope.getBinding(node[prop].name).path)) {\n        node[prop] = this.importMethod(pluginState.specified[node[prop].name], file, pluginState); // eslint-disable-line\n      }\n    });\n  }\n\n  buildDeclaratorHandler(node, prop, path, state) {\n    const file = path && path.hub && path.hub.file || state && state.file;\n    const types = this.types;\n    const pluginState = this.getPluginState(state);\n    if (!types.isIdentifier(node[prop])) return;\n\n    if (pluginState.specified[node[prop].name] && path.scope.hasBinding(node[prop].name) && path.scope.getBinding(node[prop].name).path.type === 'ImportSpecifier') {\n      node[prop] = this.importMethod(pluginState.specified[node[prop].name], file, pluginState); // eslint-disable-line\n    }\n  }\n\n  ProgramEnter(path, state) {\n    const pluginState = this.getPluginState(state);\n    pluginState.specified = Object.create(null);\n    pluginState.libraryObjs = Object.create(null);\n    pluginState.selectedMethods = Object.create(null);\n    pluginState.pathsToRemove = [];\n  }\n\n  ProgramExit(path, state) {\n    this.getPluginState(state).pathsToRemove.forEach(p => !p.removed && p.remove());\n  }\n\n  ImportDeclaration(path, state) {\n    const node = path.node; // path maybe removed by prev instances.\n\n    if (!node) return;\n    const value = node.source.value;\n    const libraryName = this.libraryName;\n    const types = this.types;\n    const pluginState = this.getPluginState(state);\n\n    if (value === libraryName) {\n      node.specifiers.forEach(spec => {\n        if (types.isImportSpecifier(spec)) {\n          pluginState.specified[spec.local.name] = spec.imported.name;\n        } else {\n          pluginState.libraryObjs[spec.local.name] = true;\n        }\n      });\n      pluginState.pathsToRemove.push(path);\n    }\n  }\n\n  CallExpression(path, state) {\n    const node = path.node;\n    const file = path && path.hub && path.hub.file || state && state.file;\n    const name = node.callee.name;\n    const types = this.types;\n    const pluginState = this.getPluginState(state);\n\n    if (types.isIdentifier(node.callee)) {\n      if (pluginState.specified[name]) {\n        node.callee = this.importMethod(pluginState.specified[name], file, pluginState);\n      }\n    }\n\n    node.arguments = node.arguments.map(arg => {\n      const argName = arg.name;\n\n      if (pluginState.specified[argName] && path.scope.hasBinding(argName) && path.scope.getBinding(argName).path.type === 'ImportSpecifier') {\n        return this.importMethod(pluginState.specified[argName], file, pluginState);\n      }\n\n      return arg;\n    });\n  }\n\n  MemberExpression(path, state) {\n    const node = path.node;\n    const file = path && path.hub && path.hub.file || state && state.file;\n    const pluginState = this.getPluginState(state); // multiple instance check.\n\n    if (!node.object || !node.object.name) return;\n\n    if (pluginState.libraryObjs[node.object.name]) {\n      // antd.Button -> _Button\n      path.replaceWith(this.importMethod(node.property.name, file, pluginState));\n    } else if (pluginState.specified[node.object.name] && path.scope.hasBinding(node.object.name)) {\n      const scope = path.scope.getBinding(node.object.name).scope; // global variable in file scope\n\n      if (scope.path.parent.type === 'File') {\n        node.object = this.importMethod(pluginState.specified[node.object.name], file, pluginState);\n      }\n    }\n  }\n\n  Property(path, state) {\n    const node = path.node;\n    this.buildDeclaratorHandler(node, 'value', path, state);\n  }\n\n  VariableDeclarator(path, state) {\n    const node = path.node;\n    this.buildDeclaratorHandler(node, 'init', path, state);\n  }\n\n  ArrayExpression(path, state) {\n    const node = path.node;\n    const props = node.elements.map((_, index) => index);\n    this.buildExpressionHandler(node.elements, props, path, state);\n  }\n\n  LogicalExpression(path, state) {\n    const node = path.node;\n    this.buildExpressionHandler(node, ['left', 'right'], path, state);\n  }\n\n  ConditionalExpression(path, state) {\n    const node = path.node;\n    this.buildExpressionHandler(node, ['test', 'consequent', 'alternate'], path, state);\n  }\n\n  IfStatement(path, state) {\n    const node = path.node;\n    this.buildExpressionHandler(node, ['test'], path, state);\n    this.buildExpressionHandler(node.test, ['left', 'right'], path, state);\n  }\n\n  ExpressionStatement(path, state) {\n    const node = path.node;\n    const types = this.types;\n\n    if (types.isAssignmentExpression(node.expression)) {\n      this.buildExpressionHandler(node.expression, ['right'], path, state);\n    }\n  }\n\n  ReturnStatement(path, state) {\n    const node = path.node;\n    this.buildExpressionHandler(node, ['argument'], path, state);\n  }\n\n  ExportDefaultDeclaration(path, state) {\n    const node = path.node;\n    this.buildExpressionHandler(node, ['declaration'], path, state);\n  }\n\n  BinaryExpression(path, state) {\n    const node = path.node;\n    this.buildExpressionHandler(node, ['left', 'right'], path, state);\n  }\n\n  NewExpression(path, state) {\n    const node = path.node;\n    this.buildExpressionHandler(node, ['callee', 'arguments'], path, state);\n  }\n\n  ClassDeclaration(path, state) {\n    const node = path.node;\n    this.buildExpressionHandler(node, ['superClass'], path, state);\n  }\n\n}\n\nexports.default = Plugin;"]}